/*
 * Copyright 2020 Red Hat, Inc. and/or its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.mvel3.javacompiler;

import org.mvel3.ClassManager;
import org.mvel3.util.PortablePath;

import java.lang.invoke.MethodHandles;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import static org.mvel3.javacompiler.JavaConfiguration.findJavaVersion;

public class KieMemoryCompiler {

    private KieMemoryCompiler() { }

    /**
     * Compile the given sources <b>without</b> adding compiled classes to the given <code>ClassLoader</code>
     * <b>classNameSourceMap</b>' key must be the <b>FQDN</b> of the class to compile
     *
     * @param classManager
     * @param classNameSourceMap
     * @param classLoader
     * @return
     */
    public static void compile(ClassManager classManager, Map<String, String> classNameSourceMap, ClassLoader classLoader) {
        compile(classManager, classNameSourceMap, classLoader, null);
    }

    /**
     * Compile the given sources <b>without</b> adding compiled classes to the given <code>ClassLoader</code>
     * <b>classNameSourceMap</b>' key must be the <b>FQDN</b> of the class to compile.
     * Additional compiler settings can be provided using JavaCompilerSettings
     *
     * @param classNameSourceMap
     * @param classLoader
     * @param compilerSettings
     * @return
     */
    public static void compile(ClassManager classManager, Map<String, String> classNameSourceMap, ClassLoader classLoader, JavaCompilerSettings compilerSettings) {
        Map<String, byte[]> byteCode = compileNoLoad(classNameSourceMap, classLoader, compilerSettings);
        classManager.define(byteCode);
    }

    /**
     * Compile the given sources and returns the generated byte codes.
     * Additional compiler settings can be provided using JavaCompilerSettings
     *
     * @param classNameSourceMap
     * @param classLoader
     * @param compilerSettings
     * @return
     */
    public static Map<String, byte[]> compileNoLoad(Map<String, String> classNameSourceMap, ClassLoader classLoader, JavaCompilerSettings compilerSettings) {
        MemoryResourceReader reader = new MemoryResourceReader();
        MemoryResourceStore store = new MemoryResourceStore();
        String[] classNames = new String[classNameSourceMap.size()];

        int i = 0;
        for (Map.Entry<String, String> entry : classNameSourceMap.entrySet()) {
            classNames[i] = toJavaSource( entry.getKey() );
            reader.add( classNames[i], entry.getValue().getBytes());
            i++;
        }
        JavaConfiguration javaConfiguration = new JavaConfiguration();
        javaConfiguration.setJavaLanguageLevel(findJavaVersion());
        JavaCompiler compiler = JavaCompilerFactory.loadCompiler(javaConfiguration);
        CompilationResult res = compilerSettings == null ?
                compiler.compile( classNames, reader, store, classLoader) :
                compiler.compile( classNames, reader, store, classLoader, compilerSettings);

        if (res.getErrors().length > 0) {
            throw new KieMemoryCompilerException(Arrays.toString( res.getErrors() ));
        }

        Map<String, byte[]> toReturn = new HashMap<>();
        for (Map.Entry<PortablePath, byte[]> entry : store.getResources().entrySet()) {
            toReturn.put(toClassName( entry.getKey().asString() ), entry.getValue());
        }

        return toReturn;
    }

    private static String toJavaSource( String s ) {
        return s.replace( '.', '/' ) + ".java";
    }

    private static String toClassName( String s ) {
        if (s.endsWith(".class")) {
            s = s.substring(0, s.length()-6);
        }
        return s.replace( '/', '.' );
    }
}
